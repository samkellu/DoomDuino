#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

#define OLED_RESET     -1
#define SCREEN_ADDRESS 0x3C

#define COLLISION_DIST 5
#define WALL_OFFSET 0
#define NUM_WALLS 4
#define UI_HEIGHT 54
#define START_TIME_MILLI 4000

// Doom logo intro screen, stored in PROGMEM to save global section space
#define LOGO_WIDTH 128
#define LOGO_HEIGHT 64
const unsigned char PROGMEM doom_logo [] = {
0x7F, 0xFF, 0xFF, 0xFE, 0x03, 0xFF, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xC3, 0xFF, 0x80, 0xFF, 0xFE,
0x3F, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFC, 0x3F, 0xFF, 0xFF, 0xF3, 0xFF, 0x81, 0xFF, 0xFC,
0x1F, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xC1, 0xFF, 0xF8,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xC1, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xC3, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xE3, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xE3, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xE7, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xF7, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xF7, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xF7, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x0F, 0xFF, 0x7F, 0xF0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x01, 0xFF, 0xDF, 0xFC, 0x07, 0xFF, 0x7F, 0xE0, 0x3F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x03, 0xFF, 0xDF, 0xFE, 0x07, 0xFF, 0x7F, 0xE0, 0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0,
0x07, 0xFF, 0x07, 0xFF, 0xDF, 0xFF, 0x07, 0xFF, 0x7F, 0xE0, 0xFF, 0xFB, 0xFF, 0xFE, 0xFF, 0xE0,
0x07, 0xFF, 0x1F, 0xFF, 0xDF, 0xFF, 0xC7, 0xFF, 0x7F, 0xE3, 0xFF, 0xFB, 0xFF, 0xBE, 0xFF, 0xE0,
0x07, 0xFF, 0x3F, 0xFF, 0xDF, 0xFF, 0xE7, 0xFF, 0x7F, 0xE7, 0xFF, 0xFB, 0xFF, 0xBE, 0xFF, 0xE0,
0x07, 0xFF, 0x7F, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xBC, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0x9C, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xF3, 0xFF, 0x9C, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xE7, 0xFF, 0x9C, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x83, 0xFF, 0x98, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x00, 0xFF, 0x88, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x3F, 0xFF, 0xFF, 0x7F, 0xFF, 0xFC, 0x00, 0x7F, 0x88, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xFF, 0x7F, 0xFF, 0xF8, 0x00, 0x1F, 0x80, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x0F, 0xFF, 0xFC, 0x3F, 0xFF, 0xF0, 0x00, 0x0F, 0x80, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0xE0, 0x00, 0x03, 0xFF, 0xF8, 0x1F, 0xFF, 0xC0, 0x00, 0x07, 0x80, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0x80, 0x00, 0x01, 0xFF, 0xF0, 0x0F, 0xFF, 0x80, 0x00, 0x01, 0x80, 0xFF, 0xE0,
0x07, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x7F, 0xC0, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xE0,
0x07, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x3F, 0x80, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0,
0x07, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0,
0x07, 0xFF, 0xF0, 0x1F, 0x80, 0x3C, 0x04, 0x01, 0xE0, 0x39, 0x02, 0xFC, 0x00, 0x70, 0xFF, 0xE0,
0x07, 0xFF, 0xE0, 0x1F, 0x80, 0x3E, 0x00, 0x01, 0xF0, 0x09, 0x02, 0xFC, 0x00, 0xF8, 0xFF, 0xE0,
0x07, 0xFF, 0x80, 0x10, 0x00, 0x27, 0x00, 0x01, 0x38, 0x09, 0x02, 0x10, 0x01, 0x98, 0xFF, 0xE0,
0x07, 0xFF, 0x00, 0x10, 0x0E, 0x21, 0x00, 0x79, 0x08, 0xF9, 0x02, 0x30, 0xB9, 0x08, 0xFF, 0xE0,
0x07, 0xFC, 0x00, 0x1F, 0x9F, 0x23, 0x00, 0xF9, 0x19, 0xF9, 0x06, 0x30, 0xF9, 0x08, 0x3F, 0xE0,
0x07, 0xF8, 0x00, 0x1F, 0x91, 0x3E, 0x00, 0xD9, 0xF1, 0x19, 0x06, 0x30, 0xC9, 0x08, 0x1F, 0xE0,
0x07, 0xF0, 0x00, 0x10, 0x31, 0x3C, 0x01, 0x89, 0xE3, 0x19, 0x06, 0x30, 0xC9, 0x08, 0x07, 0xE0,
0x07, 0xC0, 0x00, 0x10, 0x31, 0x27, 0x01, 0x89, 0x39, 0x19, 0x8C, 0x30, 0x89, 0x98, 0x03, 0xE0,
0x07, 0x80, 0x00, 0x10, 0x1F, 0x23, 0x80, 0xF9, 0x1D, 0xF8, 0xF8, 0xFC, 0x8D, 0xF8, 0x01, 0xE0,
0x07, 0x00, 0x00, 0x10, 0x0E, 0x21, 0x80, 0x7D, 0x0C, 0xF8, 0x70, 0xFC, 0x88, 0xF0, 0x00, 0x60,
0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Gun sprite and mask
#define GUN_WIDTH   32
#define GUN_HEIGHT  32
const unsigned char PROGMEM gun_bmp[] = {
0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x01, 0xc4, 0x00, 0x00, 0x02, 0x04, 0x00,
0x00, 0x02, 0x02, 0x00, 0x00, 0x02, 0xea, 0x00, 0x00, 0x04, 0xd1, 0x00, 0x00, 0x09, 0x88, 0x80,
0x00, 0x19, 0x00, 0x00, 0x00, 0x0d, 0xc2, 0x80, 0x00, 0x29, 0x81, 0xc0, 0x00, 0x0b, 0xa2, 0x20,
0x00, 0x31, 0x40, 0x40, 0x00, 0x23, 0x00, 0xc0, 0x00, 0x13, 0x00, 0x40, 0x00, 0x72, 0x02, 0x00,
0x00, 0x49, 0x00, 0x40, 0x01, 0xe0, 0xa8, 0x20, 0x07, 0xf1, 0x00, 0x30, 0x0b, 0xb9, 0xe0, 0xe8,
0x07, 0x5c, 0x03, 0xfc, 0x07, 0xef, 0xff, 0xee, 0x07, 0x75, 0x7f, 0xd2, 0x1b, 0xbb, 0xff, 0xb2,
0x11, 0x57, 0x7d, 0x64, 0x32, 0xaf, 0xff, 0xe8, 0x13, 0x5f, 0x75, 0xd0, 0x33, 0xff, 0xfb, 0x98,
0x17, 0xd7, 0xe5, 0x00, 0x1b, 0x8f, 0xb2, 0x30, 0x03, 0x7d, 0x58, 0x10, 0x6f, 0xbf, 0xec, 0x20
};

const unsigned char PROGMEM gun_bmp_mask[] = {
0x00, 0x00, 0x70, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x07, 0xfe, 0x00,
0x00, 0x07, 0xff, 0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x1f, 0xff, 0xc0,
0x00, 0x3f, 0xff, 0x80, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x7f, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xf0,
0x00, 0x7f, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xe0, 0x00, 0x7f, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xc0,
0x00, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xfc,
0x1f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff,
0x3f, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xfc,
0x7f, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xf0
};

// Muzzle flash sprite
#define FLASH_WIDTH 16
#define FLASH_HEIGHT 15
const unsigned char PROGMEM muzzle_flash_bmp [] = {
0x01, 0x00, 0x03, 0xC0, 0x05, 0xC0, 0x07, 0xE0, 0x0F, 0xE0, 0x3F, 0xE0, 0x3F, 0xD0, 0x3F, 0xFC,
0x3F, 0xFC, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0x2F, 0xFC, 
};

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Setup button pins
const int shoot_btn = 5;
const int l_btn = 4;
const int f_btn = 3;
const int r_btn = 2;

// Defines the texture that a wall will have
enum texture {
  CHECK,
  STRIPE_V,
  STRIPE_H,
  STRIPE_D
};

// Represents a place in 2D space
struct vec2 {
  float x, y;
};

// Represents a wall as a line between two points with a texture
struct wall {
  vec2 points[2];
  texture tex;
};

// Number of degrees per tick
const int rotSpeed = 5;

float pow2(float x) { return x * x; }

float dist2(vec2 v, vec2 u) { return pow2(v.x - u.x) + pow2(v.y - u.y); }

void setup() {

  // Initializes hardware
  Serial.begin(9600);
  pinMode(l_btn, INPUT_PULLUP);
  pinMode(f_btn, INPUT_PULLUP);
  pinMode(r_btn, INPUT_PULLUP);
  pinMode(shoot_btn, INPUT_PULLUP);

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // Runs intro sequence
  display.clearDisplay();
  display.drawBitmap(0, 0, doom_logo,  LOGO_WIDTH, LOGO_HEIGHT, WHITE);
  display.display();
  delay(START_TIME_MILLI);
  display.clearDisplay();

  // Initializes player state
  vec2 p = { 20.0f, 20.0f };
  int pa = 0;
  int shot_timer = 0;

  // Initializes walls
  const wall PROGMEM walls[] = {
    {10, 10, 10, 120, CHECK},
    {10, 120, 120, 120, CHECK},
    {120, 120, 120, 10, CHECK},
    {120, 10, 10, 10, CHECK}
    // {40.0f, 40.0f, 40.0f, 50.0f, CHECK},
    // {40.0f, 50.0f, 50.0f, 50.0f, CHECK},
    // {50.0f, 50.0f, 50.0f, 40.0f, CHECK},
    // {50.0f, 40.0f, 40.0f, 40.0f, CHECK}
  };

  raycast(walls, p, pa, false);

  display.setTextSize(1);
  display.setTextColor(WHITE);

  int score = 0;

  // Waits for inputs continually (main game loop)
  while (true) {
    int l = digitalRead(l_btn);
    int r = digitalRead(r_btn);
    int f = digitalRead(f_btn);
    int shoot = digitalRead(shoot_btn);
    
    if (shoot == 0 && shot_timer == 0) {
      shot_timer = 5;
    }

    if (shot_timer > 0) {
      shot_timer--;
    }

    if (l == 0) {
      pa = (pa - rotSpeed < 0 ? pa - rotSpeed + 360 : pa - rotSpeed);
    }

    if (r == 0) {
      pa = (pa + rotSpeed >= 360 ? pa + rotSpeed - 360 : pa + rotSpeed);
    }

    if (f == 0) {
      vec2 pn = {p.x + 2*cos(pa * (PI/180)), p.y + 2*sin(pa * (PI/180))};
      if (!collision_detection(walls, pn)) {
        p = pn;
      }
    }

    display.clearDisplay();
    for (int i = 0; i < SCREEN_WIDTH; i++) {
      display.drawPixel(i, UI_HEIGHT, WHITE);
    }

    char buf[16];
    // Displays the players current score
    display.setCursor(2, UI_HEIGHT + 3);
    sprintf(buf, "SCORE: %i", score);
    display.println(buf);

    // Displays the current game time
    display.setCursor(SCREEN_WIDTH/2 + 2, UI_HEIGHT + 3);
    sprintf(buf, "TIME: %i", (millis() - START_TIME_MILLI)/1000);
    display.println(buf);

    // Runs the raycasting function if any input has been detected
    raycast(walls, p, pa, shot_timer > 0);
    display.display();
  }
}

// Runs a pseudo-3D raycasting algorithm on the environment around the player
void raycast(wall* walls, vec2 p, int pa, bool show_gun) {

  // Defines the camera's depth of view and field of view
  float dov = 10.0f;
  float fov = 80.0f;

  float x3 = p.x;
  float y3 = p.y;
  float x4, y4;

  // Defines the number of rays
  for (int i = 0; i < 128; i+=2) {

    // Calculates the angle at which the ray is projected
    float angle = (i*(fov/127.0f)) - (fov/2.0f);

    // Projects the endpoint of the ray
    x4 = p.x + dov*cosf((pa + angle) * (PI/180));
    y4 = p.y + dov*sinf((pa + angle) * (PI/180));

    float dist = 100000.0f;
    vec2 pt_final = { NULL, NULL };
    wall cur_wall;
    int cur_edge2pt;

    // Checks if the vector from the camera to the ray's endpoint intersects any walls
    for (int w = 0; w < NUM_WALLS; w++) {

      float x1 = walls[w].points[0].x;
      float y1 = walls[w].points[0].y;
      float x2 = walls[w].points[1].x;
      float y2 = walls[w].points[1].y;

      float denominator = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);

      // vectors do not ever intersect
      if (denominator == 0) continue;

      float t = ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denominator;
      float u = -((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3))/denominator;

      // Case where the vectors intersect
      if (t > 0 && t < 1 && u > 0) {

        vec2 pt = { x1 + t * (x2 - x1), y1 + t * (y2 - y1) };
        float ptDist2 = dist2(pt, p);

        // Checks if the intersected wall is the closest to the camera
        if (ptDist2 < dist) {
          dist = ptDist2;
          pt_final = pt;
          cur_wall = walls[w];
          cur_edge2pt = dist2(pt, cur_wall.points[0]);
        }
      }
    }

    if (pt_final.x != NULL) {

      int length = 25000 / dist;

      // Draws lines at the edges of walls
      int wall_len = dist2(cur_wall.points[0], cur_wall.points[1]);
      if (cur_edge2pt < 2 || wall_len - cur_edge2pt < 2) {
        vertical_line(i, length);
        continue;
      }

      if (cur_wall.tex == CHECK) {
        check_line(i, length, (cur_edge2pt % 1000) < 500);
      }
//      } else if (cur_wall.tex == STRIPE_H) {
//
//      } else if (cur_wall.tex == STRIPE_V) {
//
//      } else if (cur_wall.tex == STRIPE_D) {
//
//      }

    }
  }

  if (show_gun) {
    display.drawBitmap(SCREEN_WIDTH/2 - FLASH_WIDTH/2 + 2, UI_HEIGHT - 3*FLASH_HEIGHT/4 - GUN_HEIGHT, muzzle_flash_bmp, FLASH_WIDTH, FLASH_HEIGHT, WHITE);
  }
  
  display.drawBitmap(SCREEN_WIDTH/2 - GUN_WIDTH/2, UI_HEIGHT - GUN_HEIGHT, gun_bmp_mask,  GUN_WIDTH, GUN_HEIGHT, BLACK);
  display.drawBitmap(SCREEN_WIDTH/2 - GUN_WIDTH/2, UI_HEIGHT - GUN_HEIGHT, gun_bmp,  GUN_WIDTH, GUN_HEIGHT, WHITE);
}

void vertical_line(int x, int half_length) {
  for (int i = 0; i < half_length; i+=2) {
    display.drawPixel(x, UI_HEIGHT/2 + WALL_OFFSET + i, WHITE);
    // Ensures that the wall doesnt overlap with the UI
    if (UI_HEIGHT/2 + WALL_OFFSET - i < UI_HEIGHT) {
      display.drawPixel(x, UI_HEIGHT/2 + WALL_OFFSET - i, WHITE);
    }
  }
}

void check_line(int x, int half_length, boolean phase) {
  int lower = UI_HEIGHT/2 - half_length + WALL_OFFSET;
  int upper = UI_HEIGHT/2 + half_length + WALL_OFFSET;

  for (int i = lower; i < upper; i+=2) {

    if (i > UI_HEIGHT) {break;}

    if (phase) {
      if (i == lower || (i >= lower + half_length && i <= lower + 3*half_length/2)) {
        i += half_length/2;
      }
    } else {
      if ((i >= lower + half_length/2 && i <= lower + half_length) || (i >= lower + 3*half_length/2 && i <= upper)) {
        i += half_length/2;
      }
    }

    display.drawPixel(x, i, WHITE);
  }
  display.drawPixel(x, UI_HEIGHT/2 - half_length + WALL_OFFSET, WHITE);
  display.drawPixel(x, UI_HEIGHT/2 + half_length + WALL_OFFSET, WHITE);
}

bool collision_detection(wall walls[], vec2 p) {

  int collision_dist2 = COLLISION_DIST * COLLISION_DIST;
  for (int i = 0; i < NUM_WALLS; i++) {
    wall w = walls[i];
    float w2 = dist2(w.points[0], w.points[1]);
    if (w2 == 0) continue;

    float t = ((p.x - w.points[0].x) * (w.points[1].x - w.points[0].x) + (p.y - w.points[0].y) * (w.points[1].y - w.points[0].y)) / w2;
    float d2 = dist2(p, {w.points[0].x + t * (w.points[1].x - w.points[0].x), w.points[0].y + t * (w.points[1].y - w.points[0].y)});

    if (d2 < collision_dist2) return true;
  }

  return false;
}